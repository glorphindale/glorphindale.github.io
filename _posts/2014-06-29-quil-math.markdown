---
layout: post
title:  "quil, sin и cos"
date:   "2014-06-29 21:00:00"
categories: clojure
---

Как нарисовать круг на Кложе? Этим непростым вопросом вот уже несколько лет мучают себя последователи Рича Хики.
Сегодня мы не только ответим на этот волнующий многих вопрос с помощью LightTable, но и увидим красоту синусов и косинусов.

Для начала нам понадобится библиотека quil в project.clj
{% highlight clojure %}
(defproject visimath "0.1.0-SNAPSHOT"
  :dependencies [[org.clojure/clojure "1.5.1"]
                 [quil "2.1.0"]])

{% endhighlight %}

<a href="https://github.com/quil/quil">Quil</a/> это обёртка над <a href="http://processing.org/">Processing</a>, языком и средой для быстрого создания всяческих набросков и визуализаций.

Нарисуем круг: добавим в src/visimath/circles.clj строки
{% highlight clojure %}
(ns visimath.circles
  (:require [quil.core :as qc]))

(defn draw [])

(defn setup []
  (qc/background 0)
  (qc/ellipse 200 200 100 100))

(qc/defsketch circles
  :title "Circles"
  :size [400 400]
  :draw draw
  :setup setup
  :renderer :opengl)
{% endhighlight %}
И нажмём Ctrl+Shift+Enter. LightTable запустит процесс с Clojure, установит с ним соединение, выкачает все необходимые библиотеки и вычислить всё содержимое файла. Quil запустит набросок circles с размером экрана 400 на 400 пикселей, именем окна "Circles", один раз выполнит функцию setup, после чего будем периодически вызывать функцию draw. Результатом будет красивый белый круг на чёрном фоне.
<center><img src="/images/quil-math/1-circle.png" alt="Circle" width="800"></center>

Смысл жизни найден, на этом можно закончить.

Но мы пойдём дальше. Одна из прелестей разработки через REPL &mdash; возможность на лету менять работающую программу. Не закрывая окна с кругом поменяем содержимое функции draw на
{% highlight clojure %}
(defn draw []
  (qc/rect 100 100 100 100))
{% endhighlight %}
и отправим её в REPL, нажав Ctrl+Shift с курсором на одной из строк этой функции. Получим на экране ещё и квадрат. Теперь мы можем, без рекомпиляции и перезапуска, простым изменением содержимого функции экспериментировать с решением нашей задачи.

Наша задача теперь &mdash; нарисовать бегающую по кругу точку. Для этого содержимое функции setup мы поменяем на
{% highlight clojure %}
(defn setup []
  (qc/smooth)
  (qc/frame-rate 30))
{% endhighlight %}
и отправим её в REPL. С картинкой ничего не произошло. Почему? Функция setup выполняется только на старте наброска. Для подхвата изменений нам придётся закрыть старый набросок и ещё раз отправить defsketch в REPL. На экране появился набросок с квадратом. Чтобы не перезапускать программу, рекомендуется в setup оставлять только настройку общих параметров приложения, таких как сглаживание (smooth), количество кадров в секунду (frame-rate) и так далее.

Информационное отступление: если в процессе работы с библиотекой quil (да и с любой другой) возникают вопросы по документации конкретной функции, можно нажать Ctrl+D с курсором на этой функции, и LightTable покажет всё что о ней знает.
<center><img src="/images/quil-math/2-help.png" alt="Help" width="800"></center>

Добавим немного движения и цвета в наш чёрно-белый мир:
{% highlight clojure %}
(defn draw []
  (qc/background 0)
  (let [ts (rem (qc/frame-count) 255)]
    (qc/fill ts (- 255 ts) 0)
    (qc/rect (+ ts 25) 100 100 100)))
{% endhighlight %}

Теперь у нас есть бегающий разноцветный квадрат. Если цвета всё ещё мало &mdash; можно удалить строку qc/background. Почему так происходит? Вызов qc/background заполняет весь кадр указанным цветом. Если этого вызова нет, Quil рисует новый кадр поверх старого.
<center><img src="/images/quil-math/3-colors.png" alt="Colors" width="800"></center>

Информационное отступление: одним из самых мощных средств отладки в LightTable являются watches(наблюдатели). Наблюдателя можно поставить на сивмол, который уже привязан к какому-то значению (!!! ТУПАЯ ФОРМУЛИРОВКА), например, в теле формы let (но не в векторе связывания в квадратных скобках). Для этого надо навести курсор на сивмол, и, либо нажать Alt+D, либо, вызвав командную панель через Ctrl+Space выбрать Editor: Watch selection.
Теперь LightTable обернёт этот сивмол в свой код, и при изменении его в работающем процессе, значение будет отправлено в LightTable и выведено в строке, где поставлен наблюдатель. Можно попробовать на строке (qc/fill ts (- 255 ts) 0), установив курсор на первое упоминание ts. В конце строки появится постоянно меняющееся значение. (см. предыдущую картинку)

Бегающие разноцветные квадраты это хорошо, но нам нужна окружность. Для этого нужна функция, которая по текущем номеру кадра будет выдавать позицию точки на окружности, плюс поменяется функция отрисовки:
{% highlight clojure %}
(defn deg->pos [radius deg]
  (let [rads (qc/radians deg)
        posx (* radius (Math/cos rads))
        posy (* radius (Math/sin rads))]
    [posx posy]))

(defn draw []
  (qc/background 0)
  (let [ts (rem (qc/frame-count) 360)
        [posx posy] (deg->pos 100 ts)]
    (qc/ellipse posx posy 5 5)))
{% endhighlight %}

Точка рисует только четверть окружности: посмотрев через наблюдателя на значение posx в вызове qc/ellipse можно увидеть координаты от -100 до 100. Можно добавить смещение прямо в функцию deg->pos, но это сильно повредит возможностям использования этой функции в других местах проекта. Поэтому возьмём макрос qc/with-translation, который сместит начало координат на указанный вектор для всех операция в теле макроса, а после окончания этих операция вернёт всё на место:

{% highlight clojure %}
(defn setup []
  (qc/smooth)
  (qc/no-stroke)
  (qc/background 0)
  (qc/frame-rate 30))

(defn draw []
  (let [ts (rem (qc/frame-count) 360)
        [posx posy] (deg->pos 100 ts)]
    (qc/with-translation [(/ (qc/width) 2) (/ (qc/height) 2)]
      (qc/ellipse posx posy 5 5))))
{% endhighlight %}
Ctrl+Enter, и теперь по экрану точка выписывает окружность, а благодаря тому, что мы не вызываем в draw очистку экрана через qc/background, через некоторое время будет видна вся окружность.
<center><img src="/images/quil-math/4-circle.png" alt="Circle" width="800"></center>

Самые пытливые спросят: а что, если поиграть коэффициентами аргументов синуса и косинуса?
{% highlight clojure %}
(defn deg->pos [radius deg]
  (let [rads (qc/radians deg)
        posx (* radius (Math/cos (* 3 rads)))
        posy (* radius (Math/sin (* 2 rads)))]
    [posx posy]))
{% endhighlight %}

<center><img src="/images/quil-math/5-koeff.png" alt="Koeff" width="800"></center>
Эффект интересный, но не очень удобно каждый раз править коэффициенты и вызывать qc/background 0 для очистки экрана. Добавим интерактивности, позволим управлять коэффициентами с помощью клавиш:

{% highlight clojure %}
(ns visimath.circles
  (:import [java.awt.event KeyEvent])
  (:require [quil.core :as qc]))

(def state (atom {:sin 1 :cos 1}))

(defn deg->pos [radius deg cos-k sin-k]
  (let [rads (qc/radians (* 1 deg))
        posx (* radius (Math/cos (* cos-k rads)))
        posy (* radius (Math/sin (* sin-k rads)))]
    [posx posy]))
(def psize 10)

(defn draw []
  (let [ts (rem (qc/frame-count) 360)
        cos-k (@state :cos)
        sin-k (@state :sin)
        center-x (/ (qc/width) 2)
        center-y (/ (qc/height) 2)
        [posx posy] (deg->pos 100 ts cos-k sin-k)]
    
    (qc/with-fill [255 25]
      (qc/with-translation [center-x center-y]
        (qc/ellipse posx posy psize psize)))))

(defn key-pressed []
  (qc/background 0)
  (cond
   (= (qc/key-code) KeyEvent/VK_DOWN)
      (swap! state update-in [:cos] dec)
   (= (qc/key-code) KeyEvent/VK_UP)
      (swap! state update-in [:cos] inc)
   (= (qc/key-code) KeyEvent/VK_LEFT)
      (swap! state update-in [:sin] dec)
   (= (qc/key-code) KeyEvent/VK_RIGHT)
      (swap! state update-in [:sin] inc)))

(qc/defsketch circles
  :title "Circles"
  :size [400 400]
  :draw draw
  :setup setup
  :key-pressed key-pressed
  :renderer :opengl)
{% endhighlight %}

<center><img src="/images/quil-math/6-changes.png" alt="Changes" width="800"></center>

Для большей наглядности будем рисовать отдельные части координаты точки:
{% highlight clojure %}
(defn draw []
  (let [ts (rem (qc/frame-count) 360)
        cos-k (@state :cos)
        sin-k (@state :sin)
        center-x (/ (qc/width) 2)
        center-y (/ (qc/height) 2)
        [posx posy] (deg->pos 100 ts cos-k sin-k)]
    
    (qc/with-fill [0 10]
      (qc/rect 0 15 (qc/width) 35)
      (qc/rect 15 0 35 (qc/height)))
    
    (qc/with-fill [255 25]
      (qc/with-translation [center-x center-y]
        (qc/ellipse posx posy psize psize))
      (qc/with-translation [center-x 20]
        (qc/ellipse posx 20 psize psize))
      (qc/with-translation [20 center-y]
        (qc/ellipse 20 posy psize psize)))
    ))
{% endhighlight %}

Текущее состояние можно взять в [гисте](https://gist.github.com/glorphindale/1b97f91d101e888c1541)

Следующий щаг в исследовании синусов и косинусов &mdash; увидеть все комбинации сразу:

{% highlight clojure %}
(defn deg->pos [radius deg cos-k sin-k]
  (let [rads (qc/radians deg)
        posx (* radius (Math/cos (* cos-k rads)))
        posy (* radius (Math/sin (* sin-k rads)))]
    [posx posy]))

(def psize 3)
(def radius 30)

(defn draw []
  (let [frame (qc/frame-count)
        ts (rem frame 360)
        color (rem frame 256)]
    
    (qc/no-stroke)
    (doseq [x (range 1 9) y (range 1 9)]
      (let [[posx posy] (deg->pos radius ts x y)]
        (qc/with-translation [(* x 3 radius) (* y 3 radius)]
          (qc/with-fill [100 100 255 25]
            (qc/ellipse posx posy psize psize))))))))

(defn setup []
  (qc/smooth)
  (qc/no-stroke)
  (qc/background 0)
  (qc/frame-rate 60))

(defn key-pressed []
  (qc/background 0))

(qc/defsketch circles
  :title "Circles"
  :size [800 800]
  :draw draw
  :setup setup
  :key-pressed key-pressed
  :renderer :opengl)
{% endhighlight %}

С высоты птичьего полёта можно увидеть много интересного:
<center><img src="/images/quil-math/7-all-big.png" alt="All the circles" width="800"></center>

"Поиграв с коэффициентами" в формуле можно получить много других интересных форм:
<center><img src="/images/quil-math/8-others.png" alt="Other circles" width="800"></center>

Полный файл с кодом можно взять [на GitHub](https://github.com/glorphindale/visimath/blob/master/src/visimath/circles.clj).
